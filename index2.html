<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Hand Tracking Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Video Preview (Mirrored) */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 240px;
            height: 180px;
            border: 2px solid #555;
            border-radius: 12px;
            overflow: hidden;
            z-index: 10;
            transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
        }
        #videoElement { width: 100%; height: 100%; object-fit: cover; }

        /* UI Overlay */
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            z-index: 20;
            background: rgba(10, 10, 10, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            width: 200px;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.1rem; color: #00ffff; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.85rem; color: #bbb; }
        .key { font-weight: bold; }
        .val { color: #ff00ff; font-family: monospace; }
        .status-box { 
            margin-top: 15px; 
            padding-top: 10px; 
            border-top: 1px solid #444; 
            color: #00ffaa; 
            font-size: 1rem; 
            text-align: center;
        }
        .instruction { font-size: 0.75rem; color: #888; margin-top: 5px; font-style: italic; text-align: center;}
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="info">
        <h1>Particle Controller</h1>
        <div class="row"><span class="key">‚úä 0 Fingers</span> <span class="val">Sphere</span></div>
        <div class="row"><span class="key">‚òùÔ∏è 1 Finger</span> <span class="val">Heart</span></div>
        <div class="row"><span class="key">‚úåÔ∏è 2 Fingers</span> <span class="val">Flower</span></div>
        <div class="row"><span class="key">ü§ü 3 Fingers</span> <span class="val">Saturn</span></div>
        <div class="row"><span class="key">üñê 4 Fingers</span> <span class="val">Cube</span></div>
        <div class="row"><span class="key">üñê 5 Fingers</span> <span class="val">Galaxy</span></div>
        <div class="row"><span class="key">ü§ò Rock</span> <span class="val">Firework</span></div>
        <div class="row"><span class="key">ü§ô Shaka</span> <span class="val">DNA</span></div>
        <div class="status-box">Shape: <span id="current-shape">SPHERE</span></div>
        <div class="instruction">Pinch thumb & index to expand!</div>
    </div>

    <div id="video-container">
        <video id="videoElement"></video>
    </div>

<script>
    // --- 1. CONFIGURATION ---
    const PARTICLE_COUNT = 10000;
    const PARTICLE_SIZE = 0.15;
    const MORPH_SPEED = 0.08;

    // --- 2. THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 18;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 3. PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    
    // Arrays to hold the *target* positions and colors (for morphing)
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const targetColors = new Float32Array(PARTICLE_COUNT * 3);

    // Initial fill
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i*3] = (Math.random()-0.5)*10;
        positions[i*3+1] = (Math.random()-0.5)*10;
        positions[i*3+2] = (Math.random()-0.5)*10;
        
        colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Particle Material
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        map: sprite,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 4. SHAPE GENERATOR ---
    const colorHelper = new THREE.Color();
    let currentShape = 'sphere';

    function setShape(type) {
        currentShape = type;
        document.getElementById('current-shape').innerText = type.toUpperCase();
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const t = i / PARTICLE_COUNT; // Normalized index 0..1
            let x, y, z, r, g, b;

            if (type === 'heart') {
                // Heart Curve
                const phi = t * Math.PI * 2;
                x = 16 * Math.pow(Math.sin(phi), 3);
                y = 13 * Math.cos(phi) - 5 * Math.cos(2*phi) - 2 * Math.cos(3*phi) - Math.cos(4*phi);
                z = (Math.random() - 0.5) * 4;
                // Scale down
                x *= 0.35; y *= 0.35;
                // Color: Red/Pink
                colorHelper.setHSL(0.95 + Math.random()*0.1, 1.0, 0.6);

            } else if (type === 'flower') {
                // Rose Curve
                const k = 4; // petals
                const theta = t * Math.PI * 2 * 10;
                const rad = 6 * Math.cos(k * theta);
                x = rad * Math.cos(theta);
                y = rad * Math.sin(theta);
                z = (Math.random() - 0.5) * 2;
                // Color: Magenta/Purple
                colorHelper.setHSL(0.8 + t * 0.1, 0.9, 0.6);

            } else if (type === 'saturn') {
                // Planet
                if (i < PARTICLE_COUNT * 0.7) {
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                    const theta = Math.sqrt((PARTICLE_COUNT * 0.7) * Math.PI) * phi;
                    x = 3 * Math.cos(theta) * Math.sin(phi);
                    y = 3 * Math.sin(theta) * Math.sin(phi);
                    z = 3 * Math.cos(phi);
                    colorHelper.setHSL(0.1, 0.8, 0.6); // Orange
                } else {
                    // Ring
                    const angle = t * Math.PI * 2 * 20;
                    const rad = 5 + Math.random() * 2.5;
                    x = rad * Math.cos(angle);
                    z = rad * Math.sin(angle);
                    y = (Math.random() - 0.5) * 0.2;
                    colorHelper.setHSL(0.15, 0.6, 0.7); // Beige
                }
                // Tilt
                const tilt = 0.4;
                const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                y = ty; z = tz;

            } else if (type === 'galaxy') {
                // Spiral
                const arms = 3;
                const armOffset = (i % arms) * (2 * Math.PI / arms);
                const dist = Math.random() * 9;
                const angle = dist * 1.5 + armOffset;
                x = dist * Math.cos(angle);
                z = dist * Math.sin(angle);
                y = (Math.random() - 0.5) * (8 - dist) * 0.3; // Bulge
                // Color: Center (yellow) -> Edge (Blue/Purple)
                colorHelper.setHSL(0.6 + (1 - dist/9)*0.4, 0.8, 0.6);

            } else if (type === 'cube') {
                // Grid Cube
                const size = 7;
                x = (Math.random() - 0.5) * size;
                y = (Math.random() - 0.5) * size;
                z = (Math.random() - 0.5) * size;
                // Snap to grid
                if (Math.random() > 0.3) {
                    const axis = i % 3;
                    if (axis===0) x = Math.round(x);
                    if (axis===1) y = Math.round(y);
                    if (axis===2) z = Math.round(z);
                }
                colorHelper.setHSL(0.5, 1.0, 0.5); // Cyan

            } else if (type === 'dna') {
                // Double Helix
                const angle = t * Math.PI * 2 * 5;
                const strand = i % 2 === 0 ? 1 : -1;
                x = 3 * Math.cos(angle + (strand * Math.PI));
                z = 3 * Math.sin(angle + (strand * Math.PI));
                y = (t - 0.5) * 15;
                colorHelper.setHSL(i%2===0 ? 0.3 : 0.6, 1.0, 0.5); // Green & Blue

            } else if (type === 'firework') {
                // Explosion
                const r = Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
                colorHelper.setHSL(Math.random(), 1.0, 0.6); // Rainbow

            } else {
                // Sphere (Default)
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 4;
                x = r * Math.cos(theta) * Math.sin(phi);
                y = r * Math.sin(theta) * Math.sin(phi);
                z = r * Math.cos(phi);
                colorHelper.setHSL(0.6, 1.0, 0.7); // Light Blue
            }

            targetPositions[i3] = x;
            targetPositions[i3+1] = y;
            targetPositions[i3+2] = z;
            
            targetColors[i3] = colorHelper.r;
            targetColors[i3+1] = colorHelper.g;
            targetColors[i3+2] = colorHelper.b;
        }
    }

    // Initialize
    setShape('sphere');

    // --- 5. HAND TRACKING ---
    const videoElement = document.getElementById('videoElement');
    let pinchScale = 1;

    function isFingerUp(landmarks, tipIdx, pipIdx) {
        if (tipIdx === 4) { // Thumb special logic
            const dx = landmarks[4].x - landmarks[17].x;
            const dy = landmarks[4].y - landmarks[17].y;
            return Math.sqrt(dx*dx + dy*dy) > 0.3; // Distance from pinky base
        }
        return landmarks[tipIdx].y < landmarks[pipIdx].y; // Y check (Note: Y is inverted in MediaPipe coords usually, but this works relative)
    }

    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            pinchScale = 1; // Reset zoom if no hand
            return;
        }

        const landmarks = results.multiHandLandmarks[0];

        // A. Hand Position -> Scene Rotation
        const cx = (landmarks[9].x - 0.5) * 2;
        const cy = (landmarks[9].y - 0.5) * 2;
        
        // Smooth rotation
        particles.rotation.y = -cx * 1.5;
        particles.rotation.x = -cy * 1.5;

        // B. Finger Counting
        const thumb = isFingerUp(landmarks, 4, 2);
        const index = isFingerUp(landmarks, 8, 6);
        const middle = isFingerUp(landmarks, 12, 10);
        const ring = isFingerUp(landmarks, 16, 14);
        const pinky = isFingerUp(landmarks, 20, 18);

        const count = [thumb, index, middle, ring, pinky].filter(Boolean).length;

        // C. Gesture Detection
        let newShape = currentShape;

        if (count === 0) newShape = 'sphere';
        else if (count === 5) newShape = 'galaxy';
        else if (count === 4) newShape = 'cube';
        else if (count === 3) newShape = 'saturn';
        else if (count === 2) {
            // Rock (Index + Pinky) vs Peace (Index + Middle)
            if (index && pinky && !middle && !ring) newShape = 'firework';
            else if (thumb && pinky) newShape = 'dna'; // Shaka
            else newShape = 'flower'; // Peace
        }
        else if (count === 1) newShape = 'heart';

        if (newShape !== currentShape) setShape(newShape);

        // D. Pinch Detection (Thumb tip vs Index tip)
        const dx = landmarks[4].x - landmarks[8].x;
        const dy = landmarks[4].y - landmarks[8].y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // Map distance to scale. Close = 1, Far = 2.5
        // Standard pinch is usually around 0.02 - 0.05
        // Open hand is around 0.2
        pinchScale = 1 + (dist * 4); 
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320,
        height: 240
    });
    cameraUtils.start();


    // --- 6. ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const posAttr = particles.geometry.attributes.position;
        const colAttr = particles.geometry.attributes.color;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // 1. Calculate Target with Pinch Scale
            // We apply pinchScale to the target position relative to center (0,0,0)
            const tx = targetPositions[i3] * pinchScale;
            const ty = targetPositions[i3+1] * pinchScale;
            const tz = targetPositions[i3+2] * pinchScale;

            // 2. Morph Position (Linear Interpolation)
            posAttr.array[i3] += (tx - posAttr.array[i3]) * MORPH_SPEED;
            posAttr.array[i3+1] += (ty - posAttr.array[i3+1]) * MORPH_SPEED;
            posAttr.array[i3+2] += (tz - posAttr.array[i3+2]) * MORPH_SPEED;

            // 3. Morph Color
            colAttr.array[i3] += (targetColors[i3] - colAttr.array[i3]) * 0.05;
            colAttr.array[i3+1] += (targetColors[i3+1] - colAttr.array[i3+1]) * 0.05;
            colAttr.array[i3+2] += (targetColors[i3+2] - colAttr.array[i3+2]) * 0.05;
            
            // 4. Extra Animation per shape
            if (currentShape === 'galaxy' && pinchScale < 1.5) {
                // Spin galaxy if not pinching hard
                const x = posAttr.array[i3];
                const z = posAttr.array[i3+2];
                const s = Math.sin(0.005);
                const c = Math.cos(0.005);
                posAttr.array[i3] = x * c - z * s;
                posAttr.array[i3+2] = x * s + z * c;
            }
        }
        
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;

        // Subtle idle rotation
        if (currentShape !== 'galaxy') {
            particles.rotation.z = Math.sin(time * 0.2) * 0.1;
        }

        renderer.render(scene, camera);
    }

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>